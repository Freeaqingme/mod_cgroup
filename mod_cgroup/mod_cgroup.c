/* 
**  mod_cgroup.c -- Apache sample cgroup module
**  [Autogenerated via ``apxs -n cgroup -g'']
**
*/ 
#define ACTIVE_ON 1
#define ACTIVE_OFF 0

#include "httpd.h"
#include "http_config.h"
#include "http_log.h"
#include "http_protocol.h"
#include "ap_config.h"
#include "apr_strings.h"

#include <sys/types.h>
#include <unistd.h>
#include <string.h>
#include <libcgroup.h>


typedef struct cgroup cgroup;
typedef struct cgroup_config cgroup_config;

static bool cg_enabled = 0;

struct cgroup_config {
	char default_cgroup[256];
	char cgroup[256];
	bool relinquish;
};

module AP_MODULE_DECLARE_DATA cgroup_module;

static const char* cgroup_vhost(cmd_parms *cmd, void *mconfig, const char *v1) {
	cgroup_config *dirconfig = (cgroup_config *) mconfig;
	cgroup_config *cgconf = ap_get_module_config(cmd->server->module_config, &cgroup_module);
	apr_cpystrn(cgconf->cgroup, v1, 256);
	apr_cpystrn(dirconfig->cgroup, v1, 256);
	return NULL;
}

static const char* cgroup_default(cmd_parms *cmd, void *mconfig, const char *v1) {
        cgroup_config *dirconfig = (cgroup_config *) mconfig;
        cgroup_config *cgconf = ap_get_module_config(cmd->server->module_config, &cgroup_module);
        apr_cpystrn(cgconf->default_cgroup, v1, 256);
        apr_cpystrn(dirconfig->default_cgroup, v1, 256);
	return NULL;
}

static const char* cgroup_relinquish(cmd_parms *cmd, void *mconfig, int arg) {
        cgroup_config *dirconfig = (cgroup_config *) mconfig;
        cgroup_config *cgconf = ap_get_module_config(cmd->server->module_config, &cgroup_module);
        cgconf->relinquish = ACTIVE_ON;
	dirconfig->relinquish = ACTIVE_ON;
	if (arg == 0) {
		cgconf->relinquish = ACTIVE_OFF;
		dirconfig->relinquish = ACTIVE_OFF;
	}
        return NULL;
}

static void cgroup_child_init(apr_pool_t *pool, server_rec *server)
{
	cgroup *mygroup;
	int ret;

	cgroup_config *cgconf = ap_get_module_config(server->module_config, &cgroup_module);
	if ((ret = cgroup_init()) > 0) {
		ap_log_error(APLOG_MARK, APLOG_ERR, errno, server, "Could not initialize CGroups: %s", cgroup_strerror(ret));
	}
	else if ((mygroup = cgroup_new_cgroup(cgconf->default_cgroup)) == NULL) {
		ap_log_error(APLOG_MARK, APLOG_ERR, errno, server, "Cannot allocate CGroup %s resources: %s", cgconf->default_cgroup, cgroup_strerror(ret));
	}
        else if ((ret = cgroup_get_cgroup(mygroup)) > 0) {
                ap_log_error(APLOG_MARK, APLOG_ERR, errno, server, "Cannot get CGroup %s: %s", cgconf->default_cgroup, cgroup_strerror(ret));
        }
	else if ((ret = cgroup_attach_task(mygroup)) > 0) {
		ap_log_error(APLOG_MARK, APLOG_ERR, errno, server, "Cannot assign to CGroup %s: %s", cgconf->default_cgroup, cgroup_strerror(ret));
	}
	else {
		cg_enabled = 1;
        	cgroup_free(&mygroup);
	}
}


static int cgroup_handler(request_rec *r)
{
        cgroup *mygroup;
        int ret =0;
	bool cg_assigned = FALSE;

	if (!cg_enabled) {
		return DECLINED;
	}

	cgroup_config *cgconf = ap_get_module_config(r->per_dir_config, &cgroup_module);
	mygroup = cgroup_new_cgroup(cgconf->cgroup);

	if (mygroup != NULL) {
		cg_assigned = TRUE;
	}
        if (mygroup == NULL) {
                ap_log_rerror(APLOG_MARK, APLOG_ERR, errno, r, "Cannot allocate CGroup %s resources: %s", cgconf->cgroup, cgroup_strerror(ret));
        }
        else if ((ret = cgroup_get_cgroup(mygroup)) > 0) {
                ap_log_rerror(APLOG_MARK, APLOG_ERR, errno, r, "Cannot get CGroup %s: %s", cgconf->cgroup, cgroup_strerror(ret));
        }
        else if ((ret = cgroup_attach_task(mygroup)) > 0) {
                ap_log_rerror(APLOG_MARK, APLOG_ERR, errno, r, "Cannot assign to CGroup %s: %s", cgconf->cgroup, cgroup_strerror(ret));
        }
	if (cg_assigned) {
		cgroup_free(&mygroup);
	}
	ap_log_rerror(APLOG_MARK, APLOG_DEBUG, errno, r, "Using CGroup %s", cgconf->cgroup);
	return DECLINED;
}


static int cgroup_log_transaction(request_rec *r) {
        cgroup *mygroup;
        int ret = 0;
        bool cg_assigned = FALSE;

	if (!cg_enabled) {
		return DECLINED;
	}

	cgroup_config *cgconf = ap_get_module_config(r->per_dir_config, &cgroup_module);

	if (cgconf->relinquish == ACTIVE_OFF) {
		return DECLINED;
	}

	mygroup = cgroup_new_cgroup(cgconf->default_cgroup);
	if (mygroup != NULL) {
		cg_assigned = TRUE;
	}
	if (mygroup == NULL) {
                ap_log_rerror(APLOG_MARK, APLOG_ERR, errno, r, "Cannot allocate CGroup %s resources: %s", cgconf->default_cgroup, cgroup_strerror(ret));
        }
        else if ((ret = cgroup_get_cgroup(mygroup)) > 0) {
                ap_log_rerror(APLOG_MARK, APLOG_ERR, errno, r, "Cannot get CGroup %s: %s", cgconf->default_cgroup, cgroup_strerror(ret));
        }
        else if ((ret = cgroup_attach_task(mygroup)) > 0) {
                ap_log_rerror(APLOG_MARK, APLOG_ERR, errno, r, "Cannot assign to CGroup %s: %s", cgconf->default_cgroup, cgroup_strerror(ret));
        }
        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, errno, r, "Moving back to CGroup %s", cgconf->default_cgroup);
	if (cg_assigned) {
		cgroup_free(&mygroup);
	}
	return DECLINED;
}

static void cgroup_register_hooks(apr_pool_t *p) {
	ap_hook_child_init(cgroup_child_init, NULL, NULL, APR_HOOK_MIDDLE);
	ap_hook_log_transaction(cgroup_log_transaction, NULL, NULL, APR_HOOK_LAST);
	ap_hook_handler(cgroup_handler, NULL, NULL, APR_HOOK_FIRST);
}

static void *cgroup_create_server(apr_pool_t *pool, server_rec *server) {
	cgroup_config *cgconf = apr_pcalloc(pool, sizeof(cgroup_config));
	apr_cpystrn(cgconf->default_cgroup, "/", 256);
	apr_cpystrn(cgconf->cgroup, "/", 256);
	cgconf->relinquish = ACTIVE_ON;
	return cgconf;
}

static void *cgroup_merge_server(apr_pool_t *pool, void *server1_conf, void *server2_conf) {
	cgroup_config *s1 = (cgroup_config *) server1_conf;
	cgroup_config *s2 = (cgroup_config *) server2_conf;
	cgroup_config *merged = apr_pcalloc(pool, sizeof(cgroup_config));

	apr_cpystrn(merged->default_cgroup, s1->default_cgroup, 256);
	apr_cpystrn(merged->cgroup, s2->cgroup, 256);
	merged->relinquish = s1->relinquish;

	return (void *) merged;
}

static void *cgroup_create_dir(apr_pool_t *pool, char *dirspec) {
	char *dname;
	dname = dirspec;
        cgroup_config *cgconf = apr_pcalloc(pool, sizeof(cgroup_config));
        apr_cpystrn(cgconf->default_cgroup, "/", 256);
        apr_cpystrn(cgconf->cgroup, "/", 256);
        cgconf->relinquish = ACTIVE_ON;

        return cgconf;
}

static void *cgroup_merge_dir(apr_pool_t *pool, void *parent_conf, void *child_conf) {
        cgroup_config *s1 = (cgroup_config *) parent_conf;
        cgroup_config *s2 = (cgroup_config *) child_conf;
        cgroup_config *merged = apr_pcalloc(pool, sizeof(cgroup_config));

        apr_cpystrn(merged->default_cgroup, s1->default_cgroup, 256);
	apr_cpystrn(merged->cgroup, s2->cgroup, 256);
        merged->relinquish = s1->relinquish;
	ap_log_perror(APLOG_MARK, APLOG_DEBUG, errno, pool, "s1: %s s2: %s m: %s", s1->cgroup, s2->cgroup, merged->cgroup);

        return (void *) merged;
}

static const command_rec cgroup_cmds[] = {
        AP_INIT_TAKE1("cgroup",
                        cgroup_vhost, NULL, RSRC_CONF|ACCESS_CONF,
                        "The cgroup you want to allocate the vhost to"),
        AP_INIT_TAKE1("defaultcgroup", 
			cgroup_default, NULL, RSRC_CONF,
			"The default cgroup apache should reside in"),
	AP_INIT_FLAG("relinquishcgroup",
			cgroup_relinquish, NULL, RSRC_CONF,
			"Whether to switch out of the cgroup once finishing a request. Takes 'on' or 'off'"),
        {NULL}
};

/* Dispatch list for API hooks */

module AP_MODULE_DECLARE_DATA cgroup_module = {
    STANDARD20_MODULE_STUFF, 
    cgroup_create_dir,                  /* create per-dir    config structures */
    cgroup_merge_dir,                  /* merge  per-dir    config structures */
    cgroup_create_server,     /* create per-server config structures */
    cgroup_merge_server,                  /* merge  per-server config structures */
    cgroup_cmds,                  /* table of config file commands       */
    cgroup_register_hooks  /* register hooks                      */
};

